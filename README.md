# Урок 1. Принципы ООП: Инкапсуляция, наследование, полиморфизм.

1. Добавить в класс *Animal* публичные методы двигаться(*toGo*), летать(*fly*), плавать(*swim*).
2. Создать по два класса наследника *Animal*, умеющих летать, плавать, бегать (животное может как уметь что-то одно, так и все сразу).
3. В *main* добиться того, чтобы при вызове метода действия, которое конкретное животное не умеет, оно этого не делало (кошки не летают, рыбы не ходят).
4. В файле *readme.md* в репозитории гитхаб описать какие проблемы в таком проектировании Вы увидели, а также там же написать возникшие при выполнении дз вопросы.

## Добавлено:
* Добавлены методы класса Animal:
  - [x] toGo() - идти.
  - [x] toFly() - летать.
  - [x] toSwim() - плыть.
* Добавлены классы:
  - [x] Cat - реализованно переопределение метода `toFly()`.
  - [x] Dog - реализованно переопределение метода `toFly()`.
  - [x] Penguin - реализованно переопределение метода `toFly()`.
  - [x] Dolphin - реализованно переопределение метода `toGo()`.
  - [x] Duck
  - [x] Eagle - реализованно переопределение метода `toSwim()`.

## Заметки:
* Нужно явно указывать что животное умеет делать, а что не умеет.
* Вероятнее всего нужно создать функцию, которая будет сортировать действие (способности) животного по его реальным способностям, 
или создавать отдельный класс животных, определяющий класс животного по его происхождению (Тип, Класс, Семейство, Вид, и тд.).

---

# Урок 2. Принципы ООП Абстракция и интерфейсы. Пример проектирования.

1. Создать класс *Doctor* и подумать над его состоянием и поведением.
2. Создать класс *Nurse*(Медсестра) и подумать над его состоянием и поведением.
3. Создайте интерфейсы *Goable*, *Flyable*, *Swimable*.
4. У интерфейсов должны быть методы получения скорости заданного действия: `double run()`, `double fly()`, `double swim()`.
5. Добавьте наследников этим интерфейсам, но таким образом, чтобы у каждого интерфейса было минимум по два наследника (при необходимости, добавьте в приложение новые классы).
6. Создать класс Ветеринарная Клиника (*VeterinaryClinic*).
7. У ветеринарной клиники добавьте методы получения всех бегающих, всех плавающих и всех летающих. А также методы для работы с персоналом клиники.

## Добавлено:
* Создать классы: 
  - [x] Doctor
  - [x] Nurse
  - [x] VeterinaryClinic - добавлены методы получения всех бегающих, плавающих и летающих. А также методы для работы с персоналом клиники.
* Создать интерфейсы:
  - [x] Goable - добавлен метод получения скорости `double run()`.
  - [x] Flyable - добавлен метод получения скорости `double fly()`.
  - [x] Swimable - добавлен метод получения скорости `double swim()`.

## Заметки:
* Я бы реализовал абстрактный класс *"Cотрудники"* и от него наследовал бы уже *Доктора* и *Медсестру*. Из класса *"Сотрудники"* было бы проще что-то делать с персоналом. Далее можно создать интерфейс задачи (должностные обязанности) и реализовать их к *Доктору* и *Медсестре*, если я правильно рассуждаю то создал бы отдельную папку и распределил все эти интерфейсы и классы по смыслу и логике.

---

# Урок 3. Некоторые стандартные интерфейсы Java и примеры их использования.

1. Добавить интерфейс *Copmparable<Pharmacy>* к классу *Pharmacy*. Переопределить метод `compareTo()` подсказка: можно добавить, а можно не добавлять в класс поля.
2. Создать несколько экземпляров *Pharmacy*, добавить их в *ArrayList*, написать метод, выводящий *Pharmacy* в отсортированном виде.
3. __*(усложненное, не обязательное).__ Постараться написать еще 1 метод сортировки лекарств, но уже по другому параметру.

## Добавлено:
* Добавить интерфейс:
  - [x] Copmparable\<Pharmacy> - метод `compareTo()` переопределен.
* Создать экземпляры Pharmacy:
  - [x] Созданы несколько экземпляров *Pharmacy* и добавлены в *ArrayList*.
  - [x] Метод выводящий *Pharmacy* в отсортированном виде написан.
* Написать метод сортировки:
  - [ ] Написать еще 1 метод сортировки лекарств, но уже по другому параметру.

---

# Урок 4. ООП: Обобщения. ч1.

1. Реализовать свой *LinkedList* с методами вставки в начало, конец списка, получения размера списка и получения элемента по индексу.

## Добавлено:
* Создан класс *MyLinkedList*.
* Реализованы методы:
  - [x] `addFirst(T value)` - добавление элемента в начало списка.
  - [x] `addLast(T value)` - добавление элемента в конец списка.
  - [x] `size()` - получение размера списка.
  - [x] `get(int index)` - получение элемента по индексу.

---

# Урок 5. От простого к практике.

1. Реализуйте удаление пользователей.
2. Подумать, где должен находиться метод *createUser* из *UserView* и если получится, вынести его в нужный слой. Вынести логику *dao* в слой репозитория, а от слоя *dao* избавится физически(перенести нужный код в класс репозитория, а пакет *dao* удалить).
3. **На выбор (не обязательно):** подумайте как оптимизировать код приложения (например, хэшировать все данные, а в файл писать только при выходе из приложения). Дописать код для оставшихся команд в *Commands* (можно реализовать сохранение списка *User*).\
**ИЛИ ВНЕСИТЕ СВОИ ИЗМЕНЕНИЯ В ПРОЕКТ, КОТОРЫЕ КАЖУТЬСЯ ЛОГИЧНЫМИ ВАМ!**\

## Добавлено:
  - [x] Добавлен метод `delete` - удаление пользователя по ID.
  - [x] Метод `createUser` из *UserView* находится на своём месте, т.к. согласно паттерну MVP - *UserView* подготавливает информацию как для пользователя, так для и для контроллера.
  - [x] Необходимый код из *dao* был перенесен в *UserRepository*.
  - [x] В методе *run* добавлен метод строк => `.toUpperCase()`.

---

# Урок 6. ООП Дизайн и Solid.

1. Исправить код из пакета homework, согласно принципам SOLID.
2. Если не успели реализовать какие-то задумки для приложения *notebook* (5 семинар) можно доделать и прислать вместе с этим заданием (2 ссылки на гит).

## Добавлено:
  - [x] Внесены изменения в класс *User*:
    * Заменен тип переменной *userSaver* на *Saver*, чтобы соблюсти принцип инверсии зависимостей **_(Dependency Inversion Principle, DIP)_**.
    * Конструктор *User* теперь принимает объект типа *Saver*, что позволяет передавать различные реализации интерфейса *Saver* для сохранения пользовательских данных.
  - [x] Добавлен интерфейс *Saver*:
    * *Saver* определяет метод `save`, который принимает объект типа *User* и представляет собой абстракцию для сохранения пользовательских данных.
  - [x] Создан класс *UserSaver* <u>(переименованный и изменённый класс *Persister*)</u>, который реализует интерфейс *Saver*:
    * *UserSaver* предоставляет конкретную реализацию метода `save`, который выводит сообщение о сохранении имени пользователя.
  - [x] В *Main* классе:
    * Создается экземпляр класса *UserSaver* и присваивается переменной типа *Saver*.
    * Создается объект класса *User*, который принимает имя пользователя и экземпляр *Saver*.
    * Вызывается метод `report` для вывода отчета о пользователе.
    * Вызывается метод `save`, который сохраняет данные пользователя с помощью объекта *UserSaver*.